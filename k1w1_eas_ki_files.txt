### ROOT / CONFIG / WORKFLOW ###


===== FILE: config.ts =====

// Zentrale Konfiguration f√ºr Validierungsregeln, Pfade und Token-Sch√§tzung
export const CONFIG = {
  VALIDATION: {
    // KORREKTUR: Werte reduziert, um minimalen KI-Output zu akzeptieren.
    MIN_LINES_TSX: 10, // Mindestzeilen f√ºr .tsx Dateien (war 15, jetzt 10)
    MIN_LINES_TS: 5,   // Mindestzeilen f√ºr .ts Dateien (war 10, jetzt 5)

    PATTERNS: {
      // UI-Komponenten
      COMPONENT: /\b(component|button|card|modal|header|footer|input|list|item)\b/i,
      // Bildschirme
      SCREEN: /\b(screen|page|view|home|settings|profile)\b/i,
      // React Contexts
      CONTEXT: /\b(context|provider)\b/i,
      // Custom Hooks
      HOOK: /\buse[A-Z][A-Za-z0-9_]*\b/,
      // Utility-Funktionen
      UTIL: /\b(util|helper|format|validate|constant)\b/i,
      // API-Services
      SERVICE: /\b(service|api|client)\b/i,
      // TypeScript Typen
      TYPE: /\b(type|interface)\b/i,
      // Verbotene Duplikat-Muster
      DUPLICATE: /\b(README[0-9]|App[0-9]|_copy|_backup|\([0-9]+\))\b/i,
      // Ung√ºltige Pfad-Zeichen (Windows + POSIX)
      INVALID_PATH: /\.\.\/|[\\:*?"<>|]|^[\/\\]|[\/\\]$/,
      // Konfigurationsdateien
      CONFIG_FILES: /\b(types|theme|constants|config)\.ts$|\.d\.ts$/
    },
    CONTENT_PATTERNS: {
      CONTEXT: /React\.createContext|Provider/,
      HOOK: /useState|useEffect|useRef|useCallback/,
      STYLE: /StyleSheet\.create/,
      PLACEHOLDERS: [
        '// ... existing code',
        '// ... rest of',
        '// ... other',
        '/* ... */',
        '// TODO: implement',
        '// Previous code',
        '// Add your code',
        '// Insert code here',
        '() => {}'
      ]
    }
  },
  PATHS: {
    ALLOWED_ROOT: [
      'App.tsx',
      'theme.ts',
      'package.json',
      'app.config.js',
      'README.md',
      'expo-env.d.ts',
      '.gitignore',
      'tsconfig.json',
      'babel.config.js',
      'metro.config.js'
    ] as const,
    SRC_FOLDERS: [
      'components',
      'screens',
      'contexts',
      'hooks',
      'utils',
      'services',
      'types',
      'navigation',
      'styles',
      'assets'
    ] as const,
    MAX_PATH_LENGTH: 255
  },
  TOKEN_RATIO: {
    groq: 4,
    openai: 3.8,
    anthropic: 4.2,
    gemini: 4,
    default: 4
  } as const
} as const;

// Regex-Validierung zur Kompilierzeit (robust gegen√ºber RegExp oder String)
(function validateRegex() {
  const patterns = (CONFIG.VALIDATION.PATTERNS as Record<string, RegExp | string>);
  Object.entries(patterns).forEach(([key, pattern]) => {
    try {
      if (pattern instanceof RegExp) {
        // ok
      } else if (typeof pattern === 'string') {
        new RegExp(pattern);
      } else {
        // fallback
        new RegExp(String(pattern));
      }
    } catch (e) {
      throw new Error(`Ung√ºltiges Regex in CONFIG.VALIDATION.PATTERNS.${key}: ${e}`);
    }
  });
})();


===== FILE: app.config.js =====

// app.config.js
module.exports = {
  expo: {
    name: "K1W1 AO-Style",
    slug: "k1w1-a0style",
    owner: "k1w1-pro-plus",
    version: "1.0.0",
    icon: "./assets/icon.png", 
    userInterfaceStyle: "dark", 
    splash: {
      image: "./assets/icon.png", 
      resizeMode: "contain",
      backgroundColor: "#121212" 
    },
    android: {
      package: "com.k1w1.a0style",
      adaptiveIcon: {
        foregroundImage: "./assets/adaptive-icon.png", 
        backgroundColor: "#000000" 
      },
      softwareKeyboardLayoutMode: "resize"
    },
    updates: {
      enabled: false 
    },
    assetBundlePatterns: [
      "**/*"
    ],
    ios: {
      supportsTablet: true,
      // NEU: Berechtigung f√ºr iOS Foto-Bibliothek
      infoPlist: {
        NSPhotoLibraryUsageDescription: "Die App ben√∂tigt Zugriff auf deine Fotos, um ein neues App-Icon auszuw√§hlen."
      }
    },
    web: {
      favicon: "./assets/favicon.png" 
    },
    extra: {
      eas: {
        projectId: "5e5a7791-8751-416b-9a1f-831adfffcb6c" 
      }
    },
    plugins: [
      "expo-font",
      "expo-secure-store",
      // NEU: Plugin f√ºr Image Picker
      "expo-image-picker" 
    ]
  }
};



===== FILE: .github/workflows/deploy-supabase-functions.yml =====

name: K1W1 Build Workflow

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Die Supabase job_id'
        required: true
        type: string

jobs:
  run-eas-build:
    runs-on: ubuntu-latest
    
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      JOB_ID: ${{ github.event.inputs.job_id }}

    steps:
      - uses: actions/checkout@v4

      - name: Validate Job ID
        run: |
          if [ -z "$JOB_ID" ]; then
            echo "::error::Job ID fehlt!"
            exit 1
          fi
          echo "‚úì Job ID: $JOB_ID"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Setup EAS
        uses: expo/expo-github-action@v8
        with:
          expo-version: latest
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Install dependencies
        run: npm install

      - name: Update Build Status - Building
        run: |
          curl -X PATCH "${SUPABASE_URL}/rest/v1/build_jobs?id=eq.${JOB_ID}" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\"status\":\"building\",\"github_run_id\":\"${{ github.run_id }}\"}"

      - name: Run EAS Build
        id: eas
        run: |
          BUILD_OUTPUT=$(eas build --platform android --non-interactive --no-wait 2>&1)
          echo "$BUILD_OUTPUT"
          BUILD_ID=$(echo "$BUILD_OUTPUT" | grep -oP 'Build ID: \K[a-f0-9-]+' || echo "unknown")
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT

      - name: Update Build Status - Success
        if: success()
        run: |
          curl -X PATCH "${SUPABASE_URL}/rest/v1/build_jobs?id=eq.${JOB_ID}" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\"status\":\"completed\",\"eas_build_id\":\"${{ steps.eas.outputs.build_id }}\"}"

      - name: Update Build Status - Failed
        if: failure()
        run: |
          curl -X PATCH "${SUPABASE_URL}/rest/v1/build_jobs?id=eq.${JOB_ID}" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Content-Type: application/json" \
            -d "{\"status\":\"error\",\"github_run_id\":\"${{ github.run_id }}\"}"


### SUPABASE FUNCTIONS (EAS / KI) ###


===== FILE: supabase/functions/check-eas-build/index.ts =====

// supabase/functions/check-eas-build/index.ts
// v2.3 - nutzt K1W1_ und Default ENV, stabilere Status-Checks

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

interface RequestBody {
  jobId: number;
  easToken: string;
}

interface BuildJob {
  id: number;
  status: string;
  eas_build_id: string | null;
  download_url: string | null;
}

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

function getSupabaseEnv() {
  const url =
    Deno.env.get("K1W1_SUPABASE_URL") ||
    Deno.env.get("SUPABASE_URL");

  const serviceRoleKey =
    Deno.env.get("K1W1_SUPABASE_SERVICE_ROLE_KEY") ||
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

  return { url, serviceRoleKey };
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    console.log("üîç check-eas-build (v2.3) called");

    const { url: SUPABASE_URL, serviceRoleKey: SERVICE_ROLE_KEY } =
      getSupabaseEnv();
    if (!SERVICE_ROLE_KEY || !SUPABASE_URL) {
      throw new Error("Supabase Service Key oder URL nicht konfiguriert.");
    }

    const supabaseAdmin = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

    const { jobId, easToken } = (await req.json()) as RequestBody;
    if (!jobId) throw new Error("Fehler: 'jobId' fehlt.");
    if (!easToken) throw new Error("Fehler: 'easToken' fehlt.");

    const { data: job, error: dbError } = await supabaseAdmin
      .from("build_jobs")
      .select("id, status, eas_build_id, download_url")
      .eq("id", jobId)
      .single();

    if (dbError) throw new Error(`DB Fehler: ${dbError.message}`);

    const currentJob = job as BuildJob;
    console.log(`Checking Job ${jobId}. DB Status: ${currentJob.status}`);

    // Wenn DB schon final oder noch pending/pushed -> direkt zur√ºck an App
    if (
      currentJob.status === "success" ||
      currentJob.status === "error" ||
      currentJob.status === "pending" ||
      currentJob.status === "pushed"
    ) {
      console.log(
        `Status ist '${currentJob.status}'. Kein Expo API-Call n√∂tig.`
      );
      return new Response(JSON.stringify(currentJob), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      });
    }

    // Wenn "building" ohne eas_build_id -> inkonsistent, aber nicht crashen
    if (currentJob.status === "building" && !currentJob.eas_build_id) {
      console.error(
        `Inkonsistenz: Job ${jobId} ist 'building', aber 'eas_build_id' fehlt!`
      );
      return new Response(JSON.stringify(currentJob), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      });
    }

    if (!currentJob.eas_build_id) {
      console.log(
        `Kein 'eas_build_id' f√ºr Job ${jobId}. Status: ${currentJob.status}`
      );
      return new Response(JSON.stringify(currentJob), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      });
    }

    const expoApiUrl = `https://api.expo.dev/v2/build/by-id?buildId=${currentJob.eas_build_id}`;
    const expoRes = await fetch(expoApiUrl, {
      headers: { Authorization: `Bearer ${easToken}` },
    });

    if (!expoRes.ok) {
      const errorText = await expoRes.text();
      console.error(`‚ùå Expo API Error (${expoRes.status}):`, errorText);
      if (expoRes.status === 401) {
        throw new Error("Expo Token ist ung√ºltig (401).");
      }
      // kein harter Fehler -> aktuellen DB-Status zur√ºckgeben
      return new Response(JSON.stringify(currentJob), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      });
    }

    const buildDetails = (await expoRes.json()).data;
    const newStatus = buildDetails?.status || "unknown";

    let finalStatus = currentJob.status;
    let newDownloadUrl = currentJob.download_url;

    if (newStatus === "finished") {
      finalStatus = "success";
      newDownloadUrl = buildDetails.artifacts?.buildUrl || null;
      console.log(`‚úÖ Build ${jobId} FERTIG. URL: ${newDownloadUrl}`);
    } else if (newStatus === "errored") {
      finalStatus = "error";
      console.log(`‚ùå Build ${jobId} FEHLGESCHLAGEN.`);
    } else {
      console.log(`Build ${jobId} l√§uft... (EAS Status: ${newStatus})`);
    }

    if (
      finalStatus !== currentJob.status ||
      newDownloadUrl !== currentJob.download_url
    ) {
      const { data: updatedJob, error: updateError } = await supabaseAdmin
        .from("build_jobs")
        .update({
          status: finalStatus,
          download_url: newDownloadUrl,
        })
        .eq("id", jobId)
        .select()
        .single();

      if (updateError) {
        throw new Error(`DB Update Fehler: ${updateError.message}`);
      }

      return new Response(JSON.stringify(updatedJob), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      });
    }

    // Keine √Ñnderung -> aktuellen Job zur√ºck
    return new Response(JSON.stringify(currentJob), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 200,
    });
  } catch (error: any) {
    console.error("‚ùå check-eas-build Error:", error.message);
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});


===== FILE: supabase/functions/trigger-eas-build/index.ts =====

// supabase/functions/trigger-eas-build/index.ts
// v9.3 - nutzt expoToken aus Request, ENV-Fallbacks & setzt nur vorhandene Secrets

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { Octokit } from "https://esm.sh/@octokit/rest@20.0.1";
import * as sodium from "https://esm.sh/libsodium-wrappers@0.7.13";

interface ProjectFile {
  path: string;
  content: string;
}

interface RequestBody {
  githubRepo: string;
  githubToken: string;
  files: ProjectFile[];
  expoToken?: string; // aus deinen App-Settings
}

interface BuildJob {
  id: number;
}

interface GitTreeElement {
  path: string;
  mode: "100644";
  type: "blob";
  sha: string | null;
}

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

const MAX_FILES = 200;
const MAX_FILE_SIZE = 1_500_000; // 1.5MB

function guessEncoding(content: string, path: string): "utf-8" | "base64" {
  if (
    path.endsWith(".png") ||
    path.endsWith(".jpg") ||
    path.endsWith(".jpeg") ||
    path.endsWith(".ico")
  ) {
    return "base64";
  }
  let nonAscii = 0;
  const limit = Math.min(content.length, 500);
  for (let i = 0; i < limit; i++) {
    const code = content.charCodeAt(i);
    if (code === 0) return "base64";
    if (code > 127) nonAscii++;
  }
  if (limit > 0 && nonAscii / limit > 0.1) return "base64";
  return "utf-8";
}

// GitHub Secret-Encryption
async function encryptForGitHub(publicKey: string, secret: string): Promise<string> {
  await sodium.ready;
  const key = sodium.from_base64(publicKey, sodium.base64_variants.ORIGINAL);
  const bytes = sodium.from_string(secret);
  const encryptedBytes = sodium.crypto_box_seal(bytes, key);
  return sodium.to_base64(encryptedBytes, sodium.base64_variants.ORIGINAL);
}

// Supabase ENV mit Fallback
function getSupabaseEnv() {
  const url =
    Deno.env.get("K1W1_SUPABASE_URL") ||
    Deno.env.get("SUPABASE_URL");

  const serviceRoleKey =
    Deno.env.get("K1W1_SUPABASE_SERVICE_ROLE_KEY") ||
    Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

  return { url, serviceRoleKey };
}

// Expo Token ENV-Fallback
function getExpoTokenFromEnv() {
  return (
    Deno.env.get("K1W1_EXPO_TOKEN") ||
    Deno.env.get("EXPO_TOKEN") ||
    ""
  );
}

// setzt NUR vorhandene Secrets
async function ensureRepoSecrets(
  octokit: Octokit,
  owner: string,
  repo: string,
  explicitExpoToken?: string
) {
  const { url: SUPABASE_URL, serviceRoleKey: SUPABASE_SERVICE_ROLE_KEY } = getSupabaseEnv();
  const expoToken = explicitExpoToken || getExpoTokenFromEnv();

  if (!SUPABASE_URL && !SUPABASE_SERVICE_ROLE_KEY && !expoToken) {
    console.warn(
      "‚ö†Ô∏è Auto-Secrets: Keine Werte f√ºr SUPABASE_URL / SUPABASE_SERVICE_ROLE_KEY / EXPO_TOKEN gefunden. √úberspringe."
    );
    return;
  }

  try {
    const { data: publicKey } = await octokit.actions.getRepoPublicKey({ owner, repo });

    const secrets: Record<string, string> = {};

    if (SUPABASE_URL) secrets.SUPABASE_URL = SUPABASE_URL;
    if (SUPABASE_SERVICE_ROLE_KEY) secrets.SUPABASE_SERVICE_ROLE_KEY = SUPABASE_SERVICE_ROLE_KEY;
    if (expoToken) secrets.EXPO_TOKEN = expoToken;

    const names = Object.keys(secrets);
    if (names.length === 0) {
      console.warn("‚ö†Ô∏è Auto-Secrets: Nichts zu setzen (alle Werte leer).");
      return;
    }

    for (const name of names) {
      const value = secrets[name];
      const encrypted_value = await encryptForGitHub(publicKey.key, value);
      await octokit.actions.createOrUpdateRepoSecret({
        owner,
        repo,
        secret_name: name,
        encrypted_value,
        key_id: publicKey.key_id,
      });
      console.log(`‚úÖ Secret ${name} f√ºr ${owner}/${repo} gesetzt/aktualisiert`);
    }
  } catch (err: any) {
    console.error("‚ùå Fehler beim Setzen der GitHub-Secrets:", err?.message || err);
  }
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  let newJobId: number | null = null;
  let supabaseAdmin: any = null;
  let owner = "";
  let repo = "";
  let githubToken = "";
  let octokit: Octokit;
  let currentStep = "INIT";

  try {
    console.log("üöÄ trigger-eas-build (v9.3) called");

    // 1. ENV Checks (f√ºr DB)
    currentStep = "ENV_CHECK";
    const { url: SUPABASE_URL, serviceRoleKey: SERVICE_ROLE_KEY } = getSupabaseEnv();
    if (!SERVICE_ROLE_KEY || !SUPABASE_URL) {
      throw new Error("[ENV_CHECK] Supabase ENV Variablen fehlen (SUPABASE_URL / SERVICE_ROLE_KEY).");
    }
    supabaseAdmin = createClient(SUPABASE_URL, SERVICE_ROLE_KEY);

    // 2. Body parsen
    currentStep = "PARSE_BODY";
    const body = (await req.json()) as RequestBody;

    if (!body.githubRepo || !body.githubRepo.includes("/")) {
      throw new Error("[PARSE_BODY] 'githubRepo' fehlt oder invalid (Format: owner/repo).");
    }
    if (!body.githubToken) {
      throw new Error("[PARSE_BODY] 'githubToken' fehlt.");
    }
    if (!body.files || !Array.isArray(body.files) || body.files.length === 0) {
      throw new Error("[PARSE_BODY] 'files' array fehlt oder ist leer.");
    }

    githubToken = body.githubToken;
    [owner, repo] = body.githubRepo.split("/");

    console.log(`üì¶ Job requested for ${body.files.length} files in ${body.githubRepo}`);

    if (body.files.length > MAX_FILES) {
      throw new Error(`[FILES] Zu viele Dateien: ${body.files.length} > ${MAX_FILES}`);
    }
    for (const f of body.files) {
      if (f.content.length > MAX_FILE_SIZE) {
        throw new Error(`[FILES] Datei zu gro√ü: ${f.path}`);
      }
    }

    // 3. Job in DB anlegen
    currentStep = "DB_INSERT";
    const { data: newJob, error: dbError } = await supabaseAdmin
      .from("build_jobs")
      .insert({ github_repo: body.githubRepo, status: "pending" })
      .select("id")
      .single();

    if (dbError) throw new Error(`[DB_INSERT] Insert fehlgeschlagen: ${dbError.message}`);
    newJobId = (newJob as BuildJob).id;
    console.log(`‚úÖ Job ${newJobId} erstellt`);

    // 4. GitHub / Octokit
    currentStep = "GITHUB_INIT";
    octokit = new Octokit({ auth: githubToken });
    console.log("‚úÖ Octokit initialisiert");

    // 4.1 Branch finden
    currentStep = "GITHUB_BRANCH";
    const branchCandidates = ["main", "master"];
    let parentCommitSha: string | null = null;
    let usedBranch: string | null = null;

    for (const b of branchCandidates) {
      try {
        const { data: refData } = await octokit.git.getRef({
          owner,
          repo,
          ref: `heads/${b}`,
        });
        parentCommitSha = refData.object.sha;
        usedBranch = b;
        console.log(`‚úÖ Branch gefunden: ${b} -> ${parentCommitSha}`);
        break;
      } catch (err: any) {
        console.warn(`‚ÑπÔ∏è Branch ${b} nicht gefunden: ${err.message}`);
      }
    }

    if (!parentCommitSha || !usedBranch) {
      throw new Error("[GITHUB_BRANCH] Kein main/master Branch gefunden. Repo/Token pr√ºfen.");
    }

    // 4.2 Secrets setzen (Expo/Supabase)
    currentStep = "GITHUB_SECRETS";
    await ensureRepoSecrets(octokit, owner, repo, body.expoToken);

    // 4.3 Blobs erstellen
    currentStep = "GITHUB_BLOBS";
    console.log(`üìù Erstelle ${body.files.length} Blobs...`);

    const blobResults = await Promise.all(
      body.files.map((file) => {
        const encoding = guessEncoding(file.content, file.path);
        return octokit.git.createBlob({
          owner,
          repo,
          content: file.content,
          encoding,
        });
      })
    );

    const tree: GitTreeElement[] = blobResults.map((b, i) => ({
      path: body.files[i].path,
      mode: "100644",
      type: "blob",
      sha: b.data.sha,
    }));

    console.log("‚úÖ Blobs erstellt");

    // 4.4 Tree erstellen
    currentStep = "GITHUB_CREATE_TREE";
    const { data: baseCommit } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: parentCommitSha,
    });

    const { data: treeData } = await octokit.git.createTree({
      owner,
      repo,
      tree,
      base_tree: baseCommit.tree.sha,
    });

    console.log("‚úÖ Tree erstellt");

    // 4.5 Commit
    currentStep = "GITHUB_CREATE_COMMIT";
    const commitMessage = `K1W1 App Build v${newJobId}`;
    const { data: commitData } = await octokit.git.createCommit({
      owner,
      repo,
      message: commitMessage,
      tree: treeData.sha,
      parents: [parentCommitSha],
    });

    console.log(`‚úÖ Commit erstellt: ${commitData.sha}`);

    // 4.6 Ref updaten (Push)
    currentStep = "GITHUB_PUSH";
    await octokit.git.updateRef({
      owner,
      repo,
      ref: `heads/${usedBranch}`,
      sha: commitData.sha,
      force: false,
    });

    console.log("‚úÖ Code nach GitHub gepusht");

    // 5. Job-Status -> pushed
    currentStep = "DB_UPDATE";
    await supabaseAdmin
      .from("build_jobs")
      .update({ status: "pushed", github_commit_sha: commitData.sha })
      .eq("id", newJobId);

    // 6. Workflow f√ºrs Deploy der Functions ausl√∂sen
    currentStep = "GITHUB_WORKFLOW";
    await octokit.actions.createWorkflowDispatch({
      owner,
      repo,
      workflow_id: "deploy-supabase-functions.yml",
      ref: usedBranch,
      inputs: {
        job_id: String(newJobId),
      },
    });

    console.log("‚úÖ Workflow deploy-supabase-functions.yml ausgel√∂st");

    return new Response(
      JSON.stringify({
        success: true,
        message:
          "Code gepusht, Secrets (soweit vorhanden) gesetzt und Build-Workflow ausgel√∂st.",
        job_id: newJobId,
        github_commit_sha: commitData.sha,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error: any) {
    const errorMessage = String(error?.message || "Unknown error");
    console.error(`‚ùå trigger-eas-build Error bei Schritt [${currentStep}]:`, errorMessage);
    console.error("Stack:", error.stack);

    let userFriendlyMessage = errorMessage;

    if (currentStep === "GITHUB_BRANCH") {
      userFriendlyMessage = `GitHub Fehler: Repository "${owner}/${repo}" nicht gefunden oder kein Zugriff. Pr√ºfe Token-Berechtigungen!`;
    } else if (currentStep.startsWith("GITHUB_")) {
      userFriendlyMessage = `GitHub API Fehler (${currentStep}): ${errorMessage}`;
    } else if (currentStep.startsWith("DB_")) {
      userFriendlyMessage = `Datenbank Fehler (${currentStep}): ${errorMessage}`;
    } else if (currentStep === "ENV_CHECK") {
      userFriendlyMessage =
        "Supabase ENV Variablen fehlen (SUPABASE_URL / SERVICE_ROLE_KEY). Bitte in Supabase Project Settings setzen.";
    }

    if (newJobId && supabaseAdmin) {
      await supabaseAdmin
        .from("build_jobs")
        .update({
          status: "error",
          eas_build_id: `Error at ${currentStep}: ${errorMessage.substring(0, 100)}`,
        })
        .eq("id", newJobId);
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: userFriendlyMessage,
        step: currentStep,
        details: error.stack,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});


===== FILE: supabase/functions/k1w1-handler/index.ts =====

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

interface Message {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface RequestBody {
  messages: Message[];
  apiKey: string;
  provider: 'groq' | 'gemini' | 'openai' | 'anthropic';
  model: string;
}

// Body sicher parsen
async function parseRequestBody(req: Request): Promise<RequestBody> {
  const rawBody = await req.text();
  if (!rawBody) {
    throw new Error('Request body is empty');
  }
  try {
    return JSON.parse(rawBody);
  } catch (e: any) {
    console.error('‚ùå JSON Parse Error:', e.message);
    console.error('‚ùå Raw Body (first 500 chars):', rawBody.substring(0, 500));
    throw new Error(`Invalid JSON in request body: ${e.message}`);
  }
}

// Validierung
function validateRequestBody({ messages, apiKey, provider, model }: RequestBody) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    throw new Error('Messages must be a non-empty array');
  }
  if (!apiKey || typeof apiKey !== 'string' || apiKey.length < 10) {
    throw new Error('Valid API Key is required');
  }
  if (!provider || !model) {
    throw new Error('Provider and model are required');
  }
}

// Request f√ºr Provider bauen
function buildApiRequest(body: RequestBody): {
  apiUrl: string;
  headers: Record<string, string>;
  requestBody: any;
} {
  const { messages, apiKey, provider, model } = body;
  const systemInstruction = messages.find((m) => m.role === 'system');
  const nonSystemMessages = messages.filter((m) => m.role !== 'system');

  let apiUrl: string;
  let headers: Record<string, string>;
  let requestBody: any;

  switch (provider) {
    case 'groq':
      apiUrl = 'https://api.groq.com/openai/v1/chat/completions';
      headers = {
        Authorization: `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      };
      requestBody = {
        model: model === 'auto-groq' ? 'llama-3.3-70b-versatile' : model,
        messages,
        temperature: 0.7,
        max_tokens: 4000,
      };
      break;

    case 'gemini':
      apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      headers = { 'Content-Type': 'application/json' };
      requestBody = {
        contents: nonSystemMessages.map((m) => ({
          role: m.role === 'user' ? 'user' : 'model',
          parts: [{ text: m.content }],
        })),
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 4000,
        },
      };
      if (systemInstruction) {
        requestBody.systemInstruction = {
          parts: [{ text: systemInstruction.content }],
        };
      }
      break;

    case 'openai':
      apiUrl = 'https://api.openai.com/v1/chat/completions';
      headers = {
        Authorization: `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      };
      requestBody = {
        model,
        messages,
        temperature: 0.7,
        max_tokens: 4000,
      };
      break;

    case 'anthropic':
      apiUrl = 'https://api.anthropic.com/v1/messages';
      headers = {
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
        'Content-Type': 'application/json',
      };
      requestBody = {
        model,
        messages: nonSystemMessages,
        max_tokens: 4000,
        temperature: 0.7,
      };
      if (systemInstruction) {
        requestBody.system = systemInstruction.content;
      }
      break;

    default:
      throw new Error(`Unsupported provider: ${provider}`);
  }

  return { apiUrl, headers, requestBody };
}

// Antwort parsen
function parseApiResponse(provider: string, responseText: string): string {
  try {
    const data = JSON.parse(responseText);
    let response = '';

    switch (provider) {
      case 'groq':
      case 'openai':
        response = data.choices?.[0]?.message?.content || '';
        break;
      case 'gemini':
        response = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        break;
      case 'anthropic':
        response = data.content?.[0]?.text || '';
        break;
      default:
        throw new Error('Unknown provider in parseApiResponse');
    }

    if (!response) {
      throw new Error(`${provider} returned an empty response content`);
    }

    console.log(`‚úÖ ${provider} Response: ${response.length} chars`);
    return response;
  } catch (e: any) {
    console.error(`‚ùå ${provider} Response Parse Error:`, e.message);
    throw new Error(`Invalid response from ${provider} API: ${e.message}`);
  }
}

// Handler
serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const requestData = await parseRequestBody(req);
    validateRequestBody(requestData);

    const { provider, model, messages } = requestData;
    console.log(
      `üì• k1w1-handler: Request. Provider: ${provider}, Model: ${model}, Messages: ${messages.length}`,
    );

    const { apiUrl, headers, requestBody } = buildApiRequest(requestData);

    const apiResponse = await fetch(apiUrl, {
      method: 'POST',
      headers,
      body: JSON.stringify(requestBody),
    });

    const responseText = await apiResponse.text();
    if (!apiResponse.ok) {
      console.error(
        `‚ùå ${provider} Error (${apiResponse.status}):`,
        responseText.substring(0, 500),
      );
      throw new Error(
        `[${provider} API Error ${apiResponse.status}] ${responseText.substring(
          0,
          200,
        )}`,
      );
    }

    const response = parseApiResponse(provider, responseText);

    return new Response(JSON.stringify({ response }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });
  } catch (error: any) {
    console.error('‚ùå k1w1-handler Error:', error.message);
    console.error('Stack:', error.stack);
    return new Response(
      JSON.stringify({
        error: error.message,
        details: error.stack,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      },
    );
  }
});


### TEMPLATE (Expo SDK 54 Base) ###


===== FILE: templates/expo-sdk54-base.json =====

[
  {
    "path": "package.json",
    "content": "{\n  \"name\": \"neues-projekt\",\n  \"version\": \"1.0.0\",\n  \"main\": \"node_modules/expo/AppEntry.js\",\n  \"scripts\": {\n    \"start\": \"expo start\",\n    \"android\": \"expo start --android\",\n    \"ios\": \"expo start --ios\",\n    \"web\": \"expo start --web\"\n  },\n  \"dependencies\": {\n    \"expo\": \"~54.0.0\",\n    \"react\": \"18.3.1\",\n    \"react-native\": \"0.76.5\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.25.2\",\n    \"@types/react\": \"~18.3.12\",\n    \"typescript\": \"^5.3.3\"\n  },\n  \"private\": true\n}"
  },
  {
    "path": "app.config.js",
    "content": "export default {\n  expo: {\n    name: 'neues-projekt',\n    slug: 'neues-projekt',\n    version: '1.0.0',\n    orientation: 'portrait',\n    icon: './assets/icon.png',\n    userInterfaceStyle: 'dark',\n    scheme: 'neues-projekt',\n    splash: {\n      image: './assets/splash.png',\n      resizeMode: 'contain',\n      backgroundColor: '#000000'\n    },\n    ios: {\n      supportsTablet: true,\n      bundleIdentifier: 'com.k1w1.neuesprojekt'\n    },\n    android: {\n      adaptiveIcon: {\n        foregroundImage: './assets/adaptive-icon.png',\n        backgroundColor: '#000000'\n      },\n      package: 'com.k1w1.neuesprojekt'\n    },\n    web: {\n      bundler: 'metro',\n      output: 'static',\n      favicon: './assets/favicon.png'\n    },\n    plugins: [],\n    experiments: {\n      typedRoutes: false\n    }\n  }\n};\n"
  },
  {
    "path": "App.tsx",
    "content": "import React from 'react';\nimport { StyleSheet, Text, View, StatusBar } from 'react-native';\n\nexport default function App() {\n  return (\n    <View style={styles.container}>\n      <StatusBar barStyle=\"light-content\" backgroundColor=\"#000\" />\n      <Text style={styles.title}>üöÄ Neues Projekt</Text>\n      <Text style={styles.subtitle}>Bereit f√ºr Entwicklung</Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#000',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  title: {\n    fontSize: 32,\n    fontWeight: 'bold',\n    color: '#00FF00',\n    marginBottom: 10,\n  },\n  subtitle: {\n    fontSize: 18,\n    color: '#666',\n  },\n});\n"
  },
  {
    "path": "tsconfig.json",
    "content": "{\n  \"extends\": \"expo/tsconfig.base\",\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"skipLibCheck\": true\n  }\n}\n"
  },
  {
    "path": "README.md",
    "content": "# Neues Projekt\n\nüöÄ Erstellt mit k1w1-a0style\n\n## Start\n\n```bash\nnpm install\nnpm start\n```\n\n## Features\n\n- ‚ö° Expo SDK 54\n- üé® Neon-Gr√ºn Theme\n- üì± React Native 0.76.5\n- üîß TypeScript\n\n## Entwicklung\n\nSage der KI einfach was du brauchst!\n"
  },
  {
    "path": "theme.ts",
    "content": "export const theme = {\n  palette: {\n    primary: '#00FF00',\n    secondary: '#00CC00',\n    background: '#000000',\n    card: '#111111',\n    text: {\n      primary: '#FFFFFF',\n      secondary: '#AAAAAA',\n    },\n    border: '#222222',\n    error: '#FF3333',\n    success: '#00FF00',\n  },\n  spacing: {\n    xs: 4,\n    sm: 8,\n    md: 16,\n    lg: 24,\n    xl: 32,\n  },\n  borderRadius: {\n    sm: 4,\n    md: 8,\n    lg: 16,\n  },\n};\n\nexport type Theme = typeof theme;\n"
  },
  {
    "path": ".github/workflows/deploy-supabase-functions.yml",
    "content": "name: K1W1 Build Workflow\n\non:\n  workflow_dispatch:\n    inputs:\n      job_id:\n        description: 'Die Supabase job_id'\n        required: true\n        type: string\n\njobs:\n  run-eas-build:\n    runs-on: ubuntu-latest\n\n    env:\n      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}\n      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}\n      JOB_ID: ${{ github.event.inputs.job_id }}\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Validate Job ID\n        run: |\n          if [ -z \"$JOB_ID\" ]; then\n            echo \"::error::Job ID fehlt!\"\n            exit 1\n          fi\n          echo \"‚úì Job ID: $JOB_ID\"\n\n      - name: Setup Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: 18.x\n\n      - name: Setup EAS\n        uses: expo/expo-github-action@v8\n        with:\n          expo-version: latest\n          eas-version: latest\n          token: ${{ secrets.EXPO_TOKEN }}\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Update Build Status - Building\n        run: |\n          curl -X PATCH \"${SUPABASE_URL}/rest/v1/build_jobs?id=eq.${JOB_ID}\" \\\n            -H \"apikey: ${SUPABASE_SERVICE_ROLE_KEY}\" \\\n            -H \"Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d \"{\\\"status\\\":\\\"building\\\",\\\"github_run_id\\\":\\\"${{ github.run_id }}\\\"}\"\n\n      - name: Run EAS Build\n        id: eas\n        run: |\n          BUILD_OUTPUT=$(eas build --platform android --non-interactive --no-wait 2>&1)\n          echo \"$BUILD_OUTPUT\"\n          BUILD_ID=$(echo \"$BUILD_OUTPUT\" | grep -oP 'Build ID: \\K[a-f0-9-]+' || echo \"unknown\")\n          echo \"build_id=$BUILD_ID\" >> $GITHUB_OUTPUT\n\n      - name: Update Build Status - Success\n        if: success()\n        run: |\n          curl -X PATCH \"${SUPABASE_URL}/rest/v1/build_jobs?id=eq.${JOB_ID}\" \\\n            -H \"apikey: ${SUPABASE_SERVICE_ROLE_KEY}\" \\\n            -H \"Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d \"{\\\"status\\\":\\\"completed\\\",\\\"eas_build_id\\\":\\\"${{ steps.eas.outputs.build_id }}\\\"}\"\n\n      - name: Update Build Status - Failed\n        if: failure()\n        run: |\n          curl -X PATCH \"${SUPABASE_URL}/rest/v1/build_jobs?id=eq.${JOB_ID}\" \\\n            -H \"apikey: ${SUPABASE_SERVICE_ROLE_KEY}\" \\\n            -H \"Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}\" \\\n            -H \"Content-Type: application/json\" \\\n            -d \"{\\\"status\\\":\\\"error\\\",\\\"github_run_id\\\":\\\"${{ github.run_id }}\\\"}\"\n"
  },
  {
    "path": ".gitignore",
    "content": "node_modules/\n.expo/\n.expo-shared/\nnpm-debug.*\n*.jks\n*.p8\n*.p12\n*.key\n*.mobileprovision\n*.orig.*\nweb-build/\ndist/\n.env\n.env.local\n"
  }
]


### KI-BUILDER / PROJECT / UTILS ###


===== FILE: contexts/ProjectContext.tsx =====

// contexts/ProjectContext.tsx (V13 - CREATE NEW PROJECT FIX)
import { v4 as uuidv4 } from 'uuid';
import React, { createContext, useContext, useState, useCallback, useEffect, useRef, ReactNode } from 'react';
import { Alert } from 'react-native';
import { ProjectData, ProjectFile, ChatMessage, ProjectContextProps } from './types';
import {
  saveProjectToStorage,
  loadProjectFromStorage,
  exportProjectAsZipFile,
  importProjectFromZipFile,
} from './projectStorage';
import {
  getGitHubToken,
  getWorkflowRuns,
} from './githubService';

const loadTemplateFromFile = async (): Promise<ProjectFile[]> => {
  try {
    const template = require('../templates/expo-sdk54-base.json');
    if (!Array.isArray(template) || template.length === 0) {
      throw new Error('Template ist ung√ºltig');
    }
    return template.map((file: any) => ({
      ...file,
      content: typeof file.content === 'string' ? file.content : JSON.stringify(file.content ?? '', null, 2),
    })) as ProjectFile[];
  } catch (error) {
    console.error('X Template Fehler:', error);
    return [{ path: 'README.md', content: '# Template Fehler' }];
  }
};

const SAVE_DEBOUNCE_MS = 500;
const ProjectContext = createContext<ProjectContextProps | undefined>(undefined);

export { getGitHubToken, saveGitHubToken, saveExpoToken, getExpoToken } from './githubService';

export const ProjectProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [projectData, setProjectData] = useState<ProjectData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const debouncedSave = useCallback((project: ProjectData) => {
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      saveProjectToStorage(project);
    }, SAVE_DEBOUNCE_MS);
  }, []);

  const updateProject = useCallback((updater: (prev: ProjectData) => ProjectData) => {
    setProjectData(prev => {
      if (!prev) return prev;
      const updated = updater(prev);
      const finalProject = { ...updated, lastModified: new Date().toISOString() };
      debouncedSave(finalProject);
      return finalProject;
    });
  }, [debouncedSave]);

  // ‚úÖ FIX: MERGE statt OVERWRITE!
  const updateProjectFiles = useCallback(async (files: ProjectFile[], newName?: string) => {
    updateProject(prev => {
      const fileMap = new Map(prev.files.map(f => [f.path, f]));
      files.forEach(file => {
        fileMap.set(file.path, file);
      });
      const mergedFiles = Array.from(fileMap.values());
      console.log(`üìù Dateien aktualisiert: ${files.length} ge√§ndert, ${mergedFiles.length} gesamt`);
      return {
        ...prev,
        files: mergedFiles,
        name: newName || prev.name,
      };
    });
  }, [updateProject]);

  const setProjectName = useCallback(async (newName: string) => {
    updateProject(prev => ({
      ...prev,
      name: newName,
    }));
  }, [updateProject]);

  const addChatMessage = useCallback((message: ChatMessage) => {
    updateProject(prev => ({
      ...prev,
      chatHistory: [...(prev.chatHistory || []), message],
    }));
  }, [updateProject]);

  const setPackageName = useCallback((packageName: string) => {
    updateProject(prev => ({
      ...prev,
      packageName,
    }));
  }, [updateProject]);

  // ‚úÖ NEU: Neues Projekt erstellen
  const createNewProject = useCallback(async () => {
    Alert.alert(
      'Neues Projekt',
      'M√∂chtest du ein neues Projekt erstellen? Der aktuelle Chat und alle Dateien werden zur√ºckgesetzt.',
      [
        { text: 'Abbrechen', style: 'cancel' },
        {
          text: 'Neu erstellen',
          style: 'destructive',
          onPress: async () => {
            try {
              setIsLoading(true);
              const templateFiles = await loadTemplateFromFile();
              const newProject: ProjectData = {
                id: uuidv4(),
                name: 'Neues Projekt',
                slug: 'neues-projekt',
                files: templateFiles,
                chatHistory: [], // ‚úÖ Leerer Chat
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString(),
              };
              setProjectData(newProject);
              await saveProjectToStorage(newProject);
              Alert.alert('Erfolg', 'Neues Projekt wurde erstellt!');
              console.log('‚úÖ Neues Projekt erstellt und gespeichert.');
            } catch (error: any) {
              Alert.alert('Fehler', error.message || 'Projekt konnte nicht erstellt werden');
            } finally {
              setIsLoading(false);
            }
          }
        }
      ]
    );
  }, []);

  const exportProjectAsZip = useCallback(async () => {
    if (!projectData) {
      Alert.alert('Export Fehlgeschlagen', 'Kein Projekt zum Exportieren vorhanden.');
      return;
    }
    try {
      const result = await exportProjectAsZipFile(projectData);
      Alert.alert('Export erfolgreich', `${result.fileCount} Dateien als ZIP gespeichert.`);
    } catch (error: any) {
      console.error('Fehler beim ZIP-Export:', error);
      Alert.alert('Export Fehlgeschlagen', error.message || 'Ein unbekannter Fehler ist aufgetreten.');
    }
  }, [projectData]);

  const importProjectFromZip = useCallback(async () => {
    Alert.alert(
      'Import aus ZIP',
      'WARNUNG: √úberschreibt das aktuelle Projekt. Fortfahren?',
      [
        { text: 'Abbrechen', style: 'cancel' },
        {
          text: 'Ausw√§hlen',
          onPress: async () => {
            setIsLoading(true);
            try {
              const result = await importProjectFromZipFile();
              result.project.chatHistory = []; // ‚úÖ Chat zur√ºcksetzen
              setProjectData(result.project);
              await saveProjectToStorage(result.project);
              Alert.alert('Import erfolgreich', `Projekt "${result.project.name}" importiert (${result.fileCount} Dateien).`);
            } catch (error: any) {
              Alert.alert('Import fehlgeschlagen', error.message || 'Fehler beim Importieren');
            } finally {
              setIsLoading(false);
            }
          }
        }
      ]
    );
  }, []);

  const createFile = useCallback(async (path: string, content: string) => {
    if (!path.trim()) {
      Alert.alert("Fehler", "Dateiname darf nicht leer sein.");
      return;
    }
    updateProject(prev => {
      if (prev.files.some(f => f.path === path)) {
        Alert.alert("Fehler", "Eine Datei mit diesem Pfad existiert bereits.");
        return prev;
      }
      return {
        ...prev,
        files: [...prev.files, { path, content }],
      };
    });
  }, [updateProject]);

  const deleteFile = useCallback(async (path: string) => {
    updateProject(prev => ({
      ...prev,
      files: prev.files.filter(f => f.path !== path),
    }));
  }, [updateProject]);

  const renameFile = useCallback(async (oldPath: string, newPath: string) => {
    if (!newPath.trim()) {
      Alert.alert("Fehler", "Neuer Dateiname darf nicht leer sein.");
      return;
    }
    updateProject(prev => {
      if (prev.files.some(f => f.path === newPath)) {
        Alert.alert("Fehler", "Eine Datei mit dem neuen Pfad existiert bereits.");
        return prev;
      }
      return {
        ...prev,
        files: prev.files.map(f =>
          f.path === oldPath ? { ...f, path: newPath } : f
        ),
      };
    });
  }, [updateProject]);

  useEffect(() => {
    const initializeProject = async () => {
      try {
        console.log('APP START (Context V13 - CREATE NEW PROJECT)');
        const savedProject = await loadProjectFromStorage();

        if (savedProject) {
          console.log('üìñ Projekt geladen:', savedProject.name);
          if (!savedProject.files) savedProject.files = [];
          if (!savedProject.chatHistory) {
            savedProject.chatHistory = [];
          }
          setProjectData(savedProject);
        } else {
          console.log('Kein Projekt gefunden, lade neues Template...');
          const templateFiles = await loadTemplateFromFile();
          const newProject: ProjectData = {
            id: uuidv4(),
            name: 'Neues Projekt',
            slug: 'neues-projekt',
            files: templateFiles,
            chatHistory: [],
            createdAt: new Date().toISOString(),
            lastModified: new Date().toISOString(),
          };
          setProjectData(newProject);
          await saveProjectToStorage(newProject);
          console.log('Neues Template-Projekt erstellt und gespeichert.');
        }
      } catch (error) {
        console.error('Fehler beim Laden:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initializeProject();
  }, []);

  const value: ProjectContextProps = {
    projectData,
    isLoading,
    updateProjectFiles,
    addChatMessage,
    getGitHubToken,
    getWorkflowRuns,
    createFile,
    deleteFile,
    renameFile,
    setPackageName,
    exportProjectAsZip,
    importProjectFromZip,
    createNewProject, // ‚úÖ NEU!

    updateProject: updateProjectFiles,
    setProjectName: setProjectName,

    // @ts-ignore
    updateMessages: addChatMessage,

    // @ts-ignore
    exportAndBuild: () => { Alert.alert("Fehler", "exportAndBuild ist veraltet."); return Promise.resolve(null); },

    // @ts-ignore
    deleteCurrentProject: createNewProject, // ‚úÖ Alias
    // @ts-ignore
    deleteProject: createNewProject, // ‚úÖ Alias

    // @ts-ignore
    messages: projectData?.chatHistory?.filter(msg => msg && msg.id) || [],

    // @ts-ignore
    loadProjectFromZip: importProjectFromZip,
  };

  return (
    <ProjectContext.Provider value={value}>
      {children}
    </ProjectContext.Provider>
  );
};

export const useProject = (): ProjectContextProps => {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within a ProjectProvider');
  }
  return context;
};


===== FILE: utils/chatUtils.ts =====

import { jsonrepair } from 'jsonrepair';
import { ProjectFile } from '../contexts/ProjectContext';
import { CONFIG } from '../config';

// Strukturierter Logger
const log = (level: 'INFO' | 'WARN' | 'ERROR', message: string, meta?: Record<string, any>) => {
  const timestamp = new Date().toISOString();
  const ctx = meta ? ` | ${JSON.stringify(meta)}` : '';
  console.log(`[${level}] ${timestamp} - ${message}${ctx}`);
};

// Fehlerstatistiken
const errorStats: Record<string, number> = {};
const logError = (error: string) => {
  errorStats[error] = (errorStats[error] || 0) + 1;
};

// Optimierte Zeilenz√§hlung
export const getCodeLineCount = (content: string): number => {
  if (!content) return 0;
  let lines = 0;
  const len = content.length;
  let start = 0;
  for (let i = 0; i <= len; i++) {
    if (i === len || content[i] === '\n') {
      const line = content.slice(start, i).trim();
      if (line.length > 0) lines++;
      start = i + 1;
    }
  }
  return lines;
};

// Type-Safe Content-Konvertierung
export const ensureStringContent = (content: unknown): string => {
  if (typeof content === 'string') return content;
  if (content == null) return '';
  try {
    // Node Buffer detection defensive
    // @ts-ignore
    if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(content)) {
      // @ts-ignore
      return Buffer.from(content).toString('utf8');
    }
  } catch (e) {
    // ignore
  }
  if (typeof content === 'object') {
    const c = content as any;
    if (c?.content && typeof c.content === 'string') return c.content;
    try {
      return JSON.stringify(content, null, 2);
    } catch {
      return String(content);
    }
  }
  return String(content);
};

// Normalisiert Pfade sicher
export const normalizePath = (path: string): string => {
  if (!path || typeof path !== 'string') return '';
  let normalized = path.replace(/\\/g, '/').replace(/\/+/g, '/').replace(/^\/|\/$/g, '');
  if (CONFIG.VALIDATION.PATTERNS.INVALID_PATH.test(normalized)) {
    log('ERROR', 'Ung√ºltiger Pfad', { path: normalized, reason: 'Invalid characters or traversal' });
    logError('Ung√ºltiger Pfad');
    return '';
  }
  if (normalized.length > CONFIG.PATHS.MAX_PATH_LENGTH) {
    log('ERROR', 'Pfad zu lang', { path: normalized, length: normalized.length });
    logError('Pfad zu lang');
    return '';
  }
  return normalized;
};

// Pr√ºft, ob Pfad zu einer Code-Datei geh√∂rt
export const isCodeFile = (p?: string) => !!p && (p.endsWith('.tsx') || p.endsWith('.ts') || p.endsWith('.js') || p.endsWith('.jsx'));

// Heuristik f√ºr src-Ordner (beh√§lt Logik, um Ordner vorzuschlagen)
export const getSrcFolderForFile = (filename: string, content?: string): string | null => {
  const name = normalizePath(filename).toLowerCase();
  if (!name) return null;
  try {
    if (content) {
      if (CONFIG.VALIDATION.CONTENT_PATTERNS.CONTEXT.test(content)) return 'contexts';
      if (CONFIG.VALIDATION.CONTENT_PATTERNS.HOOK.test(content) && name.endsWith('.ts')) return 'hooks';
      if (CONFIG.VALIDATION.CONTENT_PATTERNS.STYLE.test(content)) return 'components';
    }
    if (CONFIG.VALIDATION.PATTERNS.COMPONENT.test(name)) return 'components';
    if (CONFIG.VALIDATION.PATTERNS.SCREEN.test(name)) return 'screens';
    if (CONFIG.VALIDATION.PATTERNS.CONTEXT.test(name)) return 'contexts';
    if (CONFIG.VALIDATION.PATTERNS.HOOK.test(name)) return 'hooks';
    if (CONFIG.VALIDATION.PATTERNS.UTIL.test(name)) return 'utils';
    if (CONFIG.VALIDATION.PATTERNS.SERVICE.test(name)) return 'services';
    if (CONFIG.VALIDATION.PATTERNS.TYPE.test(name) || name.endsWith('.d.ts')) return 'types';
    if (name.endsWith('.tsx')) return 'components';
    if (name.endsWith('.ts')) return 'utils';
  } catch (e) {
    log('WARN', 'getSrcFolderForFile failed', { filename, err: String(e) });
  }
  return null;
};

// Validierungs-Helfer (gek√ºrzt f√ºr √úbersicht - bestehende Logik bleibt)
const validateFileStructure = (file: ProjectFile, index: number): string[] => {
  const errors: string[] = [];
  const fileNum = `Datei ${index + 1}`;
  if (!file?.path || typeof file.content === 'undefined') {
    errors.push(`${fileNum}: Ung√ºltige Struktur`);
    logError('Ung√ºltige Struktur');
  }
  const normalized = normalizePath(file?.path || '');
  if (!normalized) {
    errors.push(`${file?.path || 'undefined'}: Ung√ºltiger Pfad`);
    logError('Ung√ºltiger Pfad');
  }
  return errors;
};

const validateDuplicatePaths = (file: ProjectFile, seenPaths: Set<string>): string[] => {
  const errors: string[] = [];
  const p = normalizePath(file?.path || '');
  if (!p) return errors;
  if (seenPaths.has(p)) {
    errors.push(`${p}: DUPLIKAT!`);
    logError('Duplikat-Pfad');
  }
  return errors;
};

const validateDuplicatePatterns = (file: ProjectFile): string[] => {
  const errors: string[] = [];
  const p = normalizePath(file?.path || '');
  if (!p) return errors;
  if (CONFIG.VALIDATION.PATTERNS.DUPLICATE.test(p)) {
    errors.push(`${p}: Verbotenes Duplikat-Pattern`);
    logError('Duplikat-Pattern');
  }
  return errors;
};

// üí• KORRIGIERT: Validiert nun die flache Struktur ohne 'src/' Pr√§fix.
const validateSrcFolder = (file: ProjectFile): string[] => {
  const errors: string[] = [];
  if (!file || !file.path) return errors;
  const normalizedPath = normalizePath(file.path);
  if (!normalizedPath) {
    errors.push(`${file.path}: Ung√ºltiger Pfad`);
    logError('Ung√ºltiger Pfad');
    return errors;
  }
  const code = isCodeFile(normalizedPath);
  const isRootFile = CONFIG.PATHS.ALLOWED_ROOT.includes(normalizedPath);

  if (code && !isRootFile) {
    const pathParts = normalizedPath.split('/');

    if (pathParts.length < 2) {
      const content = ensureStringContent(file.content);
      const suggestedFolder = getSrcFolderForFile(normalizedPath, content) ||
                             (normalizedPath.endsWith('.tsx') ? 'components' : 'utils');
      errors.push(`${normalizedPath}: ‚ùå MUSS in einem Ordner sein! Vorschlag: ${suggestedFolder}/${normalizedPath}`);
      logError('Kein Ordner');
      return errors;
    }

    const topFolder = pathParts[0];
    if (!CONFIG.PATHS.SRC_FOLDERS.includes(topFolder)) {
      errors.push(`${normalizedPath}: Ung√ºltiger Ordner "${topFolder}". Erlaubt: ${CONFIG.PATHS.SRC_FOLDERS.join(', ')}`);
      logError('Ung√ºltiger Hauptordner');
    }
  }
  return errors;
};

const validatePlaceholders = (file: ProjectFile): string[] => {
  const errors: string[] = [];
  const content = ensureStringContent(file?.content);
  CONFIG.VALIDATION.CONTENT_PATTERNS.PLACEHOLDERS.forEach(pattern => {
    if (content.includes(pattern)) {
      errors.push(`${file?.path}: PLATZHALTER gefunden: "${pattern}"`);
      logError(`Platzhalter: ${pattern}`);
    }
  });
  return errors;
};

const validateMinLines = (file: ProjectFile): string[] => {
  const errors: string[] = [];
  if (!file || !file.path) return errors;
  const normalizedPath = normalizePath(file.path);
  if (!normalizedPath) {
    errors.push(`${file.path}: Ung√ºltiger Pfad`);
    logError('Ung√ºltiger Pfad');
    return errors;
  }
  const code = isCodeFile(normalizedPath);
  const isNotConfig = !CONFIG.VALIDATION.PATTERNS.CONFIG_FILES.test(normalizedPath);

  if (code && isNotConfig) {
    const content = ensureStringContent(file.content);
    const lines = getCodeLineCount(content);
    const minLines = normalizedPath.endsWith('.tsx') ? CONFIG.VALIDATION.MIN_LINES_TSX : CONFIG.VALIDATION.MIN_LINES_TS;
    if (lines < minLines) {
      errors.push(`${normalizedPath}: Zu kurz (${lines} Zeilen Code, MIN ${minLines})`);
      logError('Zu wenige Zeilen');
    }
  }
  return errors;
};

const validateImportsExports = (file: ProjectFile): string[] => {
  const errors: string[] = [];
  if (!file || !file.path) return errors;
  const normalizedPath = normalizePath(file.path);
  if (!normalizedPath) return errors;
  const code = isCodeFile(normalizedPath);
  const isNotConfig = !CONFIG.VALIDATION.PATTERNS.CONFIG_FILES.test(normalizedPath);
  if (code && isNotConfig) {
    const content = ensureStringContent(file.content);
    const hasImports = /(^|\n)\s*import\s+/m.test(content) ||
                      /module\.exports/m.test(content) ||
                      /export\s+(default|const|function|class|\{)/m.test(content);
    if (!hasImports && content.length > 120) {
      errors.push(`${normalizedPath}: Keine erkennbaren Imports/Exports - verd√§chtig`);
      logError('Keine Imports/Exports');
    }
  }
  return errors;
};

const validateStyleSheet = (file: ProjectFile): string[] => {
  const errors: string[] = [];
  if (!file || !file.path) return errors;
  const normalizedPath = normalizePath(file.path);
  if (!normalizedPath) return errors;
  const content = ensureStringContent(file.content);
  if (normalizedPath.endsWith('.tsx') && content.includes('StyleSheet.create')) {
    if (/StyleSheet\.create\(\s*\{\s*\}\s*\)/.test(content)) {
      errors.push(`${normalizedPath}: Leeres StyleSheet - unvollst√§ndig`);
      logError('Leeres StyleSheet');
    }
  }
  return errors;
};

// Haupt-Validierungsfunktion
export const validateProjectFiles = (files: ProjectFile[]): { valid: boolean; errors: string[] } => {
  const errors: string[] = [];
  const seenPaths = new Set<string>();
  if (!Array.isArray(files) || files.length === 0) {
    return { valid: true, errors: [] };
  }

  files.forEach((file, idx) => {
    errors.push(...validateFileStructure(file, idx));
    errors.push(...validateDuplicatePaths(file, seenPaths));
    errors.push(...validateDuplicatePatterns(file));
    errors.push(...validateSrcFolder(file));
    errors.push(...validatePlaceholders(file));
    errors.push(...validateMinLines(file));
    errors.push(...validateImportsExports(file));
    errors.push(...validateStyleSheet(file));
    const n = normalizePath(file.path);
    if (n) seenPaths.add(n);
  });

  if (errors.length > 0) {
    log('INFO', `Validation errors: ${JSON.stringify(errorStats)}`);
  }

  return { valid: errors.length === 0, errors };
};

// JSON Reparatur Utilities (unver√§ndert)
const fixUnquotedKeys = (json: string): string => {
  let inString = false;
  let result = '';
  let i = 0;

  while (i < json.length) {
    if (json[i] === '"') {
      inString = !inString;
      result += json[i];
      i++;
    } else if (!inString && json[i] === ':' && i > 0) {
      let keyStart = i - 1;
      while (keyStart >= 0 && /[\w-]/.test(json[keyStart])) keyStart--;
      keyStart++;
      const key = json.slice(keyStart, i);
      if (key && !json[keyStart - 1]?.match(/["']/)) {
        result = result.slice(0, -key.length) + `"${key}"`;
      }
      result += ':';
      i++;
    } else {
      result += json[i];
      i++;
    }
  }
  return result;
};

export const tryParseJsonWithRepair = (jsonString: string): ProjectFile[] | null => {
  if (!jsonString || typeof jsonString !== 'string') {
    log('ERROR', 'Ung√ºltiger JSON-String', { inputLength: (jsonString as any)?.length || 0 });
    logError('Ung√ºltiger JSON-String');
    return null;
  }

  let parsed: any;
  try {
    parsed = JSON.parse(jsonString);
  } catch (e) {
    log('WARN', 'JSON Parse Error, versuche jsonrepair...', { err: String(e) });
    try {
      const repaired = jsonrepair(jsonString);
      parsed = JSON.parse(repaired);
      log('INFO', 'JSON mit jsonrepair repariert');
    } catch (repairError) {
      log('WARN', 'jsonrepair failed, versuche konservative fixes', { err: String(repairError) });
      let r = jsonString.replace(/^\uFEFF/, '');
      r = r.replace(/,\s*([}\]])/g, '$1');
      r = fixUnquotedKeys(r);
      try {
        parsed = JSON.parse(r);
        log('INFO', 'JSON konservativ repariert');
      } catch (e3) {
        log('ERROR', `JSON Reparatur fehlgeschlagen: ${e3}`);
        logError('JSON Reparatur fehlgeschlagen');
        return null;
      }
    }
  }

  if (!Array.isArray(parsed)) {
    log('ERROR', 'Kein Array empfangen');
    logError('Kein Array empfangen');
    return null;
  }

  if (parsed.length === 0) {
    log('INFO', 'Leeres Array (Agent-Ablehnung)');
    return [];
  }

  const makeUniquePath = (basePath: string, used: Set<string>): string => {
    if (!used.has(basePath)) return basePath;
    const dot = basePath.lastIndexOf('.');
    const ext = dot !== -1 ? basePath.slice(dot) : '';
    const base = dot !== -1 ? basePath.slice(0, dot) : basePath;
    let i = 1;
    let candidate = `${base}-${i}${ext}`;
    while (used.has(candidate)) {
      i++;
      candidate = `${base}-${i}${ext}`;
    }
    return candidate;
  };

  const seen = new Set<string>();
  const files: ProjectFile[] = parsed.map((file: any) => {
    let correctedPath = normalizePath(file.path);
    if (!correctedPath) {
      const fallback = `src/utils/unknown_${Date.now()}.ts`;
      log('WARN', 'Ung√ºltiger Pfad, Fallback verwendet', { original: file.path, fallback });
      logError('Ung√ºltiger Pfad Fallback');
      correctedPath = fallback;
    }

    if (correctedPath.startsWith('src/') && !CONFIG.PATHS.ALLOWED_ROOT.includes(correctedPath)) {
      const pathAfterSrc = correctedPath.substring(4);
      const folder = pathAfterSrc.split('/')[0];
      if (CONFIG.PATHS.SRC_FOLDERS.includes(folder)) {
        correctedPath = pathAfterSrc;
        log('INFO', `Entferne 'src/' Pr√§fix: ${file.path} ‚Üí ${correctedPath}`);
      }
    }

    if (correctedPath.startsWith('src/src/')) {
      correctedPath = correctedPath.replace('src/src/', 'src/');
      log('INFO', `Doppeltes src/ entfernt: ${correctedPath}`);
    }

    const content = ensureStringContent(file.content);
    const unique = makeUniquePath(correctedPath, seen);
    seen.add(unique);
    return { ...file, path: unique, content } as ProjectFile;
  });

  const validation = validateProjectFiles(files);
  if (!validation.valid) {
    log('ERROR', 'VALIDIERUNG FEHLGESCHLAGEN:');
    validation.errors.forEach((err, idx) => {
      log('ERROR', `${idx + 1}. ${err}`);
    });
    return null;
  }

  log('INFO', `Validierung OK: ${files.length} Dateien`);
  return files;
};

export const extractJsonArray = (text: string): string | null => {
  if (!text || typeof text !== 'string') return null;
  const match = text.match(/```json\s*(ÓÄÅ[\s\S]*ÓÄÅ)\s*```|(\[[\s\S]*\])/);
  if (!match) return null;

  const jsonString = match[1] || match[2];
  if (jsonString) {
    log('INFO', `JSON gefunden (${jsonString.length} chars)`);
    return jsonString;
  }
  return null;
};

export const getErrorStats = () => ({ ...errorStats });


### DONE. Output in: k1w1_eas_ki_files.txt ###
