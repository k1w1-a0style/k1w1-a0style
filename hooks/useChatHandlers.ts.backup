// hooks/useChatHandlers.ts (V12 - NEUES MESSAGE FORMAT)
import { useCallback, useRef, useEffect } from 'react';
import { Alert } from 'react-native';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';
import * as Clipboard from 'expo-clipboard';
import { SupabaseClient } from '@supabase/supabase-js';
import { useAI, CHAT_PROVIDER, AGENT_PROVIDER, AllAIProviders } from '../contexts/AIContext';
import { useTerminal } from '../contexts/TerminalContext';
import { useProject } from '../contexts/ProjectContext';
import { ChatMessage } from '../contexts/types';
import { buildPrompt, ConversationHistory, PromptMessage } from '../lib/prompts';
import { extractJsonArray, tryParseJsonWithRepair } from '../utils/chatUtils';
import { v4 as uuidv4 } from 'uuid';

type DocumentResultAsset = NonNullable<import('expo-document-picker').DocumentPickerResult['assets']>[0];

const MAX_JSON_RETRIES = 3;
const MAX_API_RETRIES = 3;

export const useChatHandlers = (
  supabase: SupabaseClient | null,
  textInput: string,
  setTextInput: (value: string) => void,
  selectedFileAsset: DocumentResultAsset | null,
  setSelectedFileAsset: (asset: DocumentResultAsset | null) => void,
  setIsAiLoading: (loading: boolean) => void,
  setError: (error: string | null) => void
) => {
  const { projectData, updateProjectFiles, messages, addChatMessage } = useProject();
  const { config, getCurrentApiKey, rotateApiKey } = useAI();
  const { addLog } = useTerminal();
  const historyRef = useRef(new ConversationHistory());

  // Synchronisiere History bei jedem Message-Update
  useEffect(() => {
    if (messages && messages.length > 0) {
      historyRef.current.loadFromMessages(messages);
      addLog(`üß† History neu geladen (${messages.length} Eintr√§ge)`);
    }
  }, [messages, addLog]);

  const handlePickDocument = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({ type: '*/*', copyToCacheDirectory: true });
      if (!result.canceled && result.assets?.[0]) {
        const asset = result.assets[0];
        setSelectedFileAsset(asset);
        Alert.alert('Datei ausgew√§hlt', `${asset.name} (${asset.size ? (asset.size / 1024).toFixed(2) + 'KB' : '?'})`);
      } else {
        setSelectedFileAsset(null);
      }
    } catch (e) {
      Alert.alert('Fehler', 'Dateiauswahl fehlgeschlagen');
      setSelectedFileAsset(null);
    }
  };

  const callProviderWithRetry = async (
    provider: AllAIProviders,
    promptMessages: PromptMessage[],
    model: string,
    maxRetries = MAX_API_RETRIES
  ): Promise<any> => {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const apiKey = getCurrentApiKey(provider);
      if (!apiKey) {
        throw new Error(`Keine API Keys f√ºr ${provider} verf√ºgbar`);
      }
      try {
        addLog(`üìû API Call: ${provider} (Versuch ${attempt + 1}/${maxRetries})`);
        const { data, error } = await supabase.functions.invoke('k1w1-handler', {
          body: { messages: promptMessages, apiKey, provider, model },
        });
        if (error) throw error;
        return data;
      } catch (error: any) {
        const shouldRotate = error.message?.toLowerCase().includes('invalid') || error.status === 401 || error.status === 429;
        if (shouldRotate && attempt < maxRetries - 1) {
          addLog(`üîë API Key rotiert f√ºr ${provider}.`);
          await rotateApiKey(provider);
          continue;
        }
        throw error;
      }
    }
  };

  const handleSend = useCallback(
    async (customPrompt?: string) => {
      try {
        const userPrompt = customPrompt ?? textInput.trim();
        const fileToSend = selectedFileAsset;

        if ((!userPrompt && !fileToSend && !customPrompt) || !supabase || !projectData) return;

        setIsAiLoading(true);
        setError(null);

        // 1. Nachrichten-Vorbereitung (NEUES FORMAT!)
        let messageForHistory = userPrompt;
        if (fileToSend && !customPrompt) {
          const fileContent = await FileSystem.readAsStringAsync(fileToSend.uri, { encoding: 'utf8' });
          messageForHistory = `---Datei:${fileToSend.name}---\n${fileContent}\nEnde ---\n\n${userPrompt || '(Siehe Datei)'}`;
        }

        const userMessage: ChatMessage = {
          id: uuidv4(),
          role: 'user',
          content: textInput.trim() || '(Datei)',
          timestamp: new Date().toISOString(),
        };

        // User Message speichern
        setTextInput('');
        if (fileToSend && !customPrompt) setSelectedFileAsset(null);
        
        historyRef.current.addUser(messageForHistory);
        addChatMessage(userMessage);

        let groqRawResponse: string = '';

        // 2. Generator Call (Groq)
        const groqPromptMessages = buildPrompt('generator', CHAT_PROVIDER, messageForHistory, projectData.files, historyRef.current.getHistory());
        const groqData = await callProviderWithRetry(CHAT_PROVIDER, groqPromptMessages, config.selectedChatMode);
        groqRawResponse = groqData?.response?.trim() || '';
        if (!groqRawResponse) throw new Error(`${CHAT_PROVIDER} lieferte keine Antwort`);

        historyRef.current.addAssistant(groqRawResponse);

        let finalProjectFiles: any[] | null = null;
        let finalAiTextMessage: string | null = null;

        // 3. JSON-Validierung & Agent Call
        let jsonRetryAttempt = 0;
        let isJsonValid = false;

        while (jsonRetryAttempt < MAX_JSON_RETRIES && !isJsonValid) {
          const potentialJsonString = extractJsonArray(groqRawResponse);

          if (config.qualityMode === 'speed') {
            if (potentialJsonString) {
              finalProjectFiles = tryParseJsonWithRepair(potentialJsonString);
              if (finalProjectFiles) {
                isJsonValid = true;
              }
            } else {
              finalAiTextMessage = groqRawResponse;
              isJsonValid = true;
            }
          } else {
            // Quality Mode (Agent)
            const agentPromptMessages = buildPrompt('agent', AGENT_PROVIDER, groqRawResponse, projectData.files, historyRef.current.getHistory(), userPrompt);
            const agentData = await callProviderWithRetry(AGENT_PROVIDER, agentPromptMessages, config.selectedAgentMode);
            const agentResponse = agentData?.response?.trim() || '';
            if (!agentResponse) throw new Error('Agent lieferte keine Antwort');

            const agentJsonString = extractJsonArray(agentResponse);
            if (agentJsonString) {
              finalProjectFiles = tryParseJsonWithRepair(agentJsonString);
              if (finalProjectFiles) {
                isJsonValid = true;
              }
            } else {
              finalAiTextMessage = agentResponse;
              isJsonValid = true;
            }
          }

          if (!isJsonValid && jsonRetryAttempt < MAX_JSON_RETRIES - 1) {
            jsonRetryAttempt++;
            addLog(`üîÑ JSON ung√ºltig (Versuch ${jsonRetryAttempt}/${MAX_JSON_RETRIES})`);
            await new Promise(resolve => setTimeout(resolve, 1000 * jsonRetryAttempt));
            if (config.qualityMode === 'speed' && jsonRetryAttempt >= MAX_JSON_RETRIES - 1) {
              finalAiTextMessage = "Fehler: Ung√ºltiges JSON vom Generator erhalten.";
              isJsonValid = true;
            }
          } else if (!isJsonValid) {
            jsonRetryAttempt++;
          }
        }

        // 4. Verarbeitung der finalen Antwort
        let aiMessageTextToShow: string;
        if (finalProjectFiles) {
          await updateProjectFiles(finalProjectFiles);
          aiMessageTextToShow = `‚úÖ Projekt aktualisiert (${finalProjectFiles.length} Dateien${config.qualityMode === 'quality' ? ' - Agent gepr√ºft' : ''})`;
          if (jsonRetryAttempt > 0) {
            aiMessageTextToShow += ` [Fix nach ${jsonRetryAttempt} Versuchen]`;
          }
        } else if (finalAiTextMessage) {
          aiMessageTextToShow = finalAiTextMessage;
        } else {
          aiMessageTextToShow = '‚ùå Fehler: Ung√ºltiges JSON-Format nach Retries.';
          setError(aiMessageTextToShow);
        }

        // AI Message hinzuf√ºgen (NEUES FORMAT!)
        const aiMessage: ChatMessage = {
          id: uuidv4(),
          role: 'assistant',
          content: aiMessageTextToShow,
          timestamp: new Date().toISOString(),
        };
        addChatMessage(aiMessage);

      } catch (e) {
        const error = e as Error;
        console.error(`‚ùå Send Fail:`, error);
        Alert.alert('Fehler', error.message || 'Unbekannter Fehler');
        setError(error.message);
      } finally {
        setIsAiLoading(false);
      }
    },
    [textInput, selectedFileAsset, supabase, config, projectData, messages, getCurrentApiKey, rotateApiKey, updateProjectFiles, addChatMessage, setTextInput, setSelectedFileAsset, setIsAiLoading, setError, addLog]
  );

  const handleDebugLastResponse = useCallback(() => {
    const lastAiMessage = (messages || []).find(m => m.role === 'assistant');
    if (!lastAiMessage?.content || lastAiMessage.content.startsWith('‚úÖ')) {
      Alert.alert('Nichts zu debuggen', 'Keine g√ºltige Textantwort von der KI gefunden.');
      return;
    }
    const prompt = `Analysiere:\n\n\`\`\`\n${lastAiMessage.content}\n\`\`\``;
    setTextInput('Debug Anfrage...');
    handleSend(prompt);
  }, [messages, setTextInput, handleSend]);

  const handleExpoGo = useCallback(() => {
    if (!projectData) {
      Alert.alert('Fehler', 'Kein Projekt geladen');
      return;
    }
    const metroHost = '192.168.43.1:8081';
    const expUrl = `exp://${metroHost}`;
    Alert.alert(
      'Expo Go Vorschau',
      `Stellen Sie sicher, dass Metro auf dem Host l√§uft und Ihr Ger√§t im selben Netzwerk ist.\n\nURL: ${expUrl}`,
      [
        { text: 'URL kopieren', onPress: () => Clipboard.setStringAsync(expUrl) },
        { text: 'OK' },
      ]
    );
    addLog(`Expo Go URL (Manuell): ${expUrl}`);
  }, [projectData, addLog]);

  return {
    handlePickDocument,
    handleSend,
    handleDebugLastResponse,
    handleExpoGo,
  };
};
