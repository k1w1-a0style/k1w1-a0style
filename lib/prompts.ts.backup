// lib/prompts.ts (V13 - KONVERSATION ERLAUBT!)
import { AllAIProviders } from '../contexts/AIContext';
import { ProjectFile, ChatMessage } from '../contexts/types';

export interface PromptMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

// ============================================================================
// RESPONSE FORMAT DEFINITION
// ============================================================================
const JSON_RESPONSE_FORMAT = `
WENN du Code generierst, antworte NUR als valides JSON-Array:

[
  {"path":"package.json","content":"{\\"name\\":\\"musikplayer\\",\\"version\\":\\"1.0.0\\"}"},
  {"path":"App.tsx","content":"import React from 'react';\\nexport default function App() {...}"}
]

KRITISCHE REGELN F√úR JSON:
‚úÖ NUR Dateien die NEU oder GE√ÑNDERT sind
‚úÖ "content" MUSS escaped String sein (Newlines als \\n)
‚úÖ Valides JSON - sonst Fehler!
‚ùå NIEMALS "name" in package.json √§ndern (au√üer explizit gefordert)
‚ùå NIEMALS README2.md wenn README.md existiert - UPDATE stattdessen!
‚ùå KEINE Duplikate (README2, README3 etc.)
`;

// ============================================================================
// SYSTEM PROMPTS
// ============================================================================
const GENERATOR_SYSTEM_PROMPT = `
Du bist k1w1-a0style, ein freundlicher Code-Assistent f√ºr Expo SDK 54 + React Native.

üéØ DEIN VERHALTEN:

1. **KONVERSATION** (Standard):
   - Beantworte Fragen normal und freundlich
   - Erkl√§re was du tun wirst BEVOR du Code generierst
   - Frage nach, wenn etwas unklar ist
   - Liste √Ñnderungen auf (z.B. "Ich werde diese 3 Dateien √§ndern: ...")

2. **CODE-GENERIERUNG** (nur bei klaren Anfragen):
   - Wenn User sagt "baue", "erstelle", "√§ndere", "implementiere" ‚Üí Generiere JSON
   - **WICHTIG**: Erkl√§re VORHER was du √§ndern wirst (als Text)
   - **DANACH**: Generiere das JSON-Array

${JSON_RESPONSE_FORMAT}

üìã WICHTIGE CONSTRAINTS:
- Expo SDK 54.0.18
- React Native 0.81.4
- TypeScript strict mode
- Neon-Gr√ºn Theme (#00FF00)
- Mobile-first Design

üö´ VERBOTEN:
- Namen in package.json √§ndern (au√üer explizit gefordert)
- Duplikate erstellen (README2, README3 etc.)
- Bundle IDs oder Slugs √§ndern
- Stumpf JSON ausgeben ohne Erkl√§rung

üí° BEISPIEL EINER GUTEN ANTWORT:
User: "F√ºge einen Dark Mode hinzu"
Du: "Ich werde folgende √Ñnderungen vornehmen:
1. theme.ts erweitern um Dark Mode Farben
2. Ein ThemeContext erstellen f√ºr das Umschalten
3. App.tsx anpassen um den Context zu nutzen

Soll ich das umsetzen?"

[Wenn User best√§tigt oder direkt "implementiere" sagt]
[Dann JSON-Array mit den 3 Dateien]
`;

const AGENT_SYSTEM_PROMPT = `
Du bist der Quality Agent. DEINE EINZIGE AUFGABE ist es, den Generator-Output zu validieren und zu korrigieren.

<AGENT_CONSTRAINTS>
1. Pr√ºfe Generator-Antwort auf Valides JSON.
2. Pr√ºfe gegen die <FILE_CONTEXT> und die üö® GESCH√úTZTER NAME Anweisung.
3. Korrigiere alle Duplikate (z.B. README2.md in README.md umbenennen), ung√ºltige Namen oder Datei-Fehler.
4. Gib NUR das finale, korrigierte JSON-Array zur√ºck.
5. WENN NICHT VALIDE ODER NICHT KORRIGIERBAR: Gib GENAU dieses leere Array zur√ºck: [].
</AGENT_CONSTRAINTS>

${JSON_RESPONSE_FORMAT}
`;

const SYSTEM_PROMPTS: Record<AllAIProviders, string> = {
  groq: GENERATOR_SYSTEM_PROMPT,
  gemini: AGENT_SYSTEM_PROMPT,
  openai: GENERATOR_SYSTEM_PROMPT,
  anthropic: GENERATOR_SYSTEM_PROMPT,
};

// ============================================================================
// PROMPT BUILDER FUNCTION
// ============================================================================
export const buildPrompt = (
  role: 'generator' | 'agent',
  provider: AllAIProviders,
  userOrGeneratorMessage: string,
  projectFiles: ProjectFile[],
  conversationHistory: ChatMessage[],
  originalUserPrompt?: string
): PromptMessage[] => {
  let systemPromptContent = SYSTEM_PROMPTS[provider] || GENERATOR_SYSTEM_PROMPT;
  let currentMessageContent = '';

  if (role === 'generator') {
    currentMessageContent = userOrGeneratorMessage;
  } else {
    currentMessageContent = `
<INPUT_FOR_AGENT>
ORIGINAL USER REQUEST: "${originalUserPrompt || 'Unbekannt'}"
GENERATOR ANTWORTETE:
---
${userOrGeneratorMessage}
---
</INPUT_FOR_AGENT>

DEINE AUFGABE: F√ºhre die Regeln in <AGENT_CONSTRAINTS> strikt aus.
`;
  }

  // ============================================================================
  // PROJECT CONTEXT BUILDING
  // ============================================================================
  let projectContext = '';

  if (projectFiles.length === 0) {
    projectContext = `
üìÅ PROJEKT IST LEER
Erstelle Standard-Struktur:
- package.json (name: "meine-app")
- app.config.js (Expo config)
- App.tsx (Entry point)
- theme.ts (Neon-Gr√ºn Theme)
- README.md (Dokumentation)`;
  } else {
    const fileCount = projectFiles.length;
    projectContext = `
üìä PROJEKT STATUS: ${fileCount} Dateien vorhanden`;

    if (role === 'agent') {
      projectContext += `

<FILE_CONTEXT>
üóÇÔ∏è EXISTIERENDE DATEIEN IM PROJEKT (NUR DIESE EXISTIEREN!):
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`;
      projectFiles.forEach((file, idx) => {
        const lines = file.content.split('\n').length;
        const size = file.content.length;
        projectContext += `
${idx + 1}. ${file.path} (${lines} Zeilen, ${size} Zeichen)`;
      });
      projectContext += `
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
</FILE_CONTEXT>
`;
    } else {
      const paths = projectFiles.map((f) => f.path);
      projectContext += `

Dateien: ${JSON.stringify(paths)}`;
    }

    // Name Protection
    const pkgFile = projectFiles.find((f) => f.path === 'package.json');
    let protectedName = 'UNBEKANNT';
    if (pkgFile && pkgFile.content) {
      try {
        const pkg = JSON.parse(pkgFile.content);
        if (pkg.name) {
          protectedName = pkg.name;
        }
      } catch (e) {
        // Ignoriert
      }
    }

    projectContext += `

üö® GESCH√úTZTER NAME: "${protectedName}"
Dieser Name (in package.json) darf NIEMALS ge√§ndert werden (au√üer explizit gefordert)!`;

    const appConfigFile = projectFiles.find(
      (f) => f.path === 'app.config.js' || f.path === 'app.json'
    );
    if (appConfigFile) {
      projectContext += `
‚ö†Ô∏è app.config vorhanden - Namen/Slugs NICHT √§ndern!`;
    }
  }

  // ============================================================================
  // BUILD FINAL PROMPT
  // ============================================================================
  const fullSystemPrompt = `${systemPromptContent}${projectContext}`;
  const messages: PromptMessage[] = [{ role: 'system', content: fullSystemPrompt }];

  // History hinzuf√ºgen
  const HISTORY_COUNT = 6;
  const historyToUse = conversationHistory.slice(-HISTORY_COUNT);
  messages.push(...historyToUse.map(msg => ({ 
    role: msg.role === 'user' ? 'user' : 'assistant', 
    content: msg.content 
  } as PromptMessage)));

  // Current message
  messages.push({ role: 'user', content: currentMessageContent });

  console.log(`üìù Prompt (${role}/${provider}): ${messages.length} messages`);
  console.log(`   ‚Üí System: 1, History: ${historyToUse.length}, Current: 1`);

  if (messages.length < 8) {
    console.warn(`‚ö†Ô∏è WARNUNG: Prompt hat nur ${messages.length} messages!`);
  }

  return messages;
};

// ============================================================================
// CONVERSATION HISTORY CLASS
// ============================================================================
export class ConversationHistory {
  private history: ChatMessage[] = [];

  loadFromMessages(messages: ChatMessage[]) {
    this.history = [...messages].reverse();
    console.log(`üß† History geladen (${this.history.length} Eintr√§ge)`);
  }

  addUser(message: string) {
    this.history.push({
      id: `temp-${Date.now()}`,
      role: 'user',
      content: message,
      timestamp: new Date().toISOString(),
    });
  }

  addAssistant(message: string) {
    if (message.startsWith('[') && message.includes('"path":')) {
      try {
        const parsed = JSON.parse(message);
        if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].path) {
          const files = parsed.map((f: any) => f.path).join(', ');
          const summary = `[Code Update: ${parsed.length} Dateien ge√§ndert: ${files}]`;
          this.history.push({
            id: `temp-${Date.now()}`,
            role: 'assistant',
            content: summary,
            timestamp: new Date().toISOString(),
          });
          return;
        }
      } catch (e) {
        // Fallthrough
      }
    }
    this.history.push({
      id: `temp-${Date.now()}`,
      role: 'assistant',
      content: message,
      timestamp: new Date().toISOString(),
    });
  }

  getHistory(): ChatMessage[] {
    return this.history;
  }

  clear() {
    this.history = [];
    console.log('üß† History geleert');
  }

  debug() {
    console.log('=== CONVERSATION HISTORY ===');
    this.history.forEach((msg, idx) => {
      console.log(`${idx}. [${msg.role}]: ${msg.content.substring(0, 100)}...`);
    });
    console.log('===========================');
  }
}
