// contexts/ProjectContext.tsx - REPARIERT MIT FALLBACKS

import React, { createContext, useContext, useState, useCallback, useEffect, useRef, ReactNode } from 'react';
import { Alert } from 'react-native';
import { ProjectData, ProjectFile, ChatMessage, ProjectContextProps } from './types';
import {
  saveProjectToStorage,
  loadProjectFromStorage,
  exportProjectAsZipFile,
  importProjectFromZipFile,
} from './projectStorage';
import {
  createRepo,
  pushFilesToRepo,
  triggerWorkflow,
  getGitHubToken,
  getWorkflowRuns,
  createOrUpdateFile,
} from './githubService';

const SAVE_DEBOUNCE_MS = 500;

const ProjectContext = createContext<ProjectContextProps | undefined>(undefined);

// Re-export wichtige Funktionen
export { getGitHubToken, saveGitHubToken, saveExpoToken, getExpoToken } from './githubService';

export const ProjectProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [projectData, setProjectData] = useState<ProjectData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const debouncedSave = useCallback((project: ProjectData) => {
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      saveProjectToStorage(project);
    }, SAVE_DEBOUNCE_MS);
  }, []);

  const updateProject = useCallback((updater: (prev: ProjectData) => ProjectData) => {
    setProjectData(prev => {
      if (!prev) return prev;
      const updated = updater(prev);
      debouncedSave(updated);
      return updated;
    });
  }, [debouncedSave]);

  const updateProjectFiles = useCallback(async (files: ProjectFile[]) => {
    if (!projectData) return;
    
    const updatedProject = {
      ...projectData,
      files: files || [],
      lastModified: new Date().toISOString(),
    };
    
    setProjectData(updatedProject);
    debouncedSave(updatedProject);
  }, [projectData, debouncedSave]);

  const addChatMessage = useCallback((message: ChatMessage) => {
    updateProject(prev => ({
      ...prev,
      chatHistory: [...(prev.chatHistory || []), message],
      lastModified: new Date().toISOString(),
    }));
  }, [updateProject]);

  const setPackageName = useCallback((packageName: string) => {
    updateProject(prev => ({
      ...prev,
      packageName,
      lastModified: new Date().toISOString(),
    }));
  }, [updateProject]);

  const exportProjectAsZip = useCallback(async () => {
    if (!projectData) {
      Alert.alert('Export Fehlgeschlagen', 'Kein Projekt zum Exportieren vorhanden.');
      return;
    }

    try {
      const result = await exportProjectAsZipFile(projectData);
      Alert.alert(
        'Export erfolgreich',
        `Projekt "${result.projectName}" wurde als ZIP exportiert.\n\nInhalt:\n‚Ä¢ ${result.fileCount} Code-Dateien\n‚Ä¢ ${result.messageCount} Chat-Nachrichten\n‚Ä¢ Metadaten`
      );
    } catch (error: any) {
      console.error('Fehler beim ZIP-Export:', error);
      Alert.alert('Export Fehlgeschlagen', error.message || 'Ein unbekannter Fehler ist aufgetreten.');
    }
  }, [projectData]);

  const importProjectFromZip = useCallback(async () => {
    Alert.alert(
      'Import aus ZIP',
      'ZIP-Datei ausw√§hlen zum Importieren:',
      [
        { text: 'Abbrechen', style: 'cancel' },
        {
          text: 'Ausw√§hlen',
          onPress: async () => {
            setIsLoading(true);
            try {
              const result = await importProjectFromZipFile();
              setProjectData(result.project);
              await saveProjectToStorage(result.project);

              let alertMessage = `Projekt "${result.project.name}" erfolgreich importiert!\n\n‚Ä¢ ${result.fileCount} Code-Dateien\n‚Ä¢ ${result.messageCount} Chat-Nachrichten`;
              
              if (result.metadata?.exportDate) {
                alertMessage += `\n‚Ä¢ Original vom: ${new Date(result.metadata.exportDate).toLocaleDateString()}`;
              }

              Alert.alert('Import erfolgreich', alertMessage);
            } catch (error: any) {
              Alert.alert('Import fehlgeschlagen', error.message || 'Fehler beim Importieren');
            } finally {
              setIsLoading(false);
            }
          }
        }
      ]
    );
  }, []);

  // ‚úÖ REPARIERTE EXPORT & BUILD FUNKTION MIT NULL-CHECKS
  const exportAndBuild = useCallback(async (project: ProjectData): Promise<{ owner: string, repo: string } | null> => {
    console.log('üöÄ exportAndBuild wird ausgef√ºhrt...');
    console.log('üì¶ Projekt:', JSON.stringify(project, null, 2).substring(0, 500));

    // ‚úÖ SICHERER REPO NAME
    const repoName = project.slug || (project.name || 'k1w1-app')
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    const finalRepoName = repoName || 'k1w1-app';

    try {
      const repoResult = await createRepo(finalRepoName, true);
      const owner = repoResult.owner.login;

      console.log(`‚úì Repo erstellt/gefunden: ${owner}/${finalRepoName}`);

      // ‚úÖ SICHERE FILES MIT FALLBACK
      const projectFiles = Array.isArray(project.files) ? project.files : [];
      
      console.log(`‚Üí Projekt hat ${projectFiles.length} Dateien`);
      
      if (projectFiles.length > 0) {
        console.log('üìÅ Vorhandene Dateien:');
        projectFiles.forEach(f => console.log(`  - ${f.path}`));
      } else {
        console.warn('‚ö†Ô∏è Keine Dateien im Projekt gefunden!');
      }

      // ‚ö†Ô∏è SICHERHEITSFILTER: Entferne Musik-App Reste
      const musicAppFiles = [
        'equalizer.tsx', 'music-library.tsx', 'player.tsx', 'playlist.tsx',
        'id3tag-editor.tsx', 'database.ts'
      ];
      
      const cleanFiles = projectFiles.filter(file => {
        if (!file || !file.path) return false;
        
        const isMusic = musicAppFiles.some(musicFile => 
          file.path.includes(musicFile) || file.path.endsWith(musicFile)
        );
        if (isMusic) {
          console.warn(`üö® Musik-App Datei entfernt: ${file.path}`);
        }
        return !isMusic && file.content;
      });

      console.log(`‚úÖ Nach Filterung: ${cleanFiles.length} Dateien`);

      // ‚úÖ STANDARD EXPO APP ERSTELLEN
      const standardFiles: ProjectFile[] = [
        {
          path: 'package.json',
          content: JSON.stringify({
            "name": finalRepoName,
            "version": "1.0.0",
            "main": "node_modules/expo/AppEntry.js",
            "scripts": {
              "start": "expo start",
              "android": "expo start --android",
              "ios": "expo start --ios",
              "web": "expo start --web"
            },
            "dependencies": {
              "expo": "~49.0.0",
              "react": "18.2.0",
              "react-native": "0.72.6",
              "@expo/vector-icons": "^13.0.0"
            },
            "devDependencies": {
              "@babel/core": "^7.20.0",
              "@types/react": "~18.2.14",
              "typescript": "^5.1.3"
            }
          }, null, 2)
        },
        {
          path: 'app.json',
          content: JSON.stringify({
            "expo": {
              "name": project.name || "K1W1 App",
              "slug": finalRepoName,
              "version": "1.0.0",
              "orientation": "portrait",
              "platforms": ["ios", "android", "web"],
              "assetBundlePatterns": ["**/*"],
              "ios": {
                "supportsTablet": true,
                "bundleIdentifier": `com.k1w1.${finalRepoName.replace(/-/g, '')}`
              },
              "android": {
                "package": `com.k1w1.${finalRepoName.replace(/-/g, '')}`,
                "adaptiveIcon": {
                  "foregroundImage": "./assets/adaptive-icon.png",
                  "backgroundColor": "#ffffff"
                }
              }
            }
          }, null, 2)
        },
        {
          path: 'App.tsx',
          content: `import React from 'react';
import { StyleSheet, Text, View, StatusBar } from 'react-native';

export default function App() {
  return (
    <>
      <StatusBar barStyle="light-content" />
      <View style={styles.container}>
        <Text style={styles.title}>üöÄ ${project.name || 'K1W1 App'}</Text>
        <Text style={styles.subtitle}>Erfolgreich von K1W1 A0Style exportiert!</Text>
        <Text style={styles.info}>Repository: ${owner}/${finalRepoName}</Text>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0a0a0a',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#00ff88',
    textAlign: 'center',
    marginBottom: 16,
  },
  subtitle: {
    fontSize: 16,
    color: '#999999',
    textAlign: 'center',
    marginBottom: 12,
  },
  info: {
    fontSize: 12,
    color: '#666666',
    textAlign: 'center',
    marginTop: 20,
  },
});`
        },
        {
          path: 'eas.json',
          content: JSON.stringify({
            "cli": {
              "version": ">= 5.4.0"
            },
            "build": {
              "development": {
                "developmentClient": true,
                "distribution": "internal"
              },
              "preview": {
                "distribution": "internal",
                "android": {
                  "buildType": "apk"
                }
              },
              "production": {
                "android": {
                  "buildType": "apk"
                }
              }
            },
            "submit": {
              "production": {}
            }
          }, null, 2)
        },
        {
          path: 'README.md',
          content: `# ${project.name || 'K1W1 App'}

Exportiert von **K1W1 A0Style** am ${new Date().toLocaleDateString('de-DE')}

## üì± Build & Run

\`\`\`bash
# Installiere Dependencies
npm install

# Starte Entwicklungsserver
npx expo start

# Build f√ºr Android
eas build --platform android --profile preview
\`\`\`

## üöÄ EAS Build via GitHub Actions

Dieser Build wurde automatisch via GitHub Actions ausgel√∂st.

Repository: https://github.com/${owner}/${finalRepoName}
`
        },
        {
          path: '.gitignore',
          content: `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/
.env
.env.local`
        }
      ];

      // Kombiniere Standard-Dateien mit gefilterten Projekt-Dateien
      const finalFiles = [...standardFiles];
      
      // F√ºge nur zus√§tzliche Projekt-Dateien hinzu (keine Duplikate)
      cleanFiles.forEach(file => {
        const exists = finalFiles.some(f => f.path === file.path);
        if (!exists) {
          finalFiles.push(file);
        }
      });

      console.log(`üì¶ Finale Dateiliste (${finalFiles.length} Dateien):`);
      finalFiles.forEach(f => console.log(`  ‚úì ${f.path}`));

      await pushFilesToRepo(owner, finalRepoName, finalFiles);
      console.log('‚úì Alle Dateien gepusht');

      // GitHub Actions Workflow
      const workflowContent = `name: K1W1 EAS Build
on:
  workflow_dispatch:
  push:
    branches: [main]

jobs:
  build:
    name: EAS Build
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v3
      
      - name: üèó Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: npm
          
      - name: üì¶ Install dependencies
        run: npm install
        
      - name: üöÄ Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: \${{ secrets.EXPO_TOKEN }}
          
      - name: üì± Build Android APK
        run: |
          eas build --platform android --profile preview --non-interactive --clear-cache
`;

      await createOrUpdateFile(
        owner,
        finalRepoName,
        '.github/workflows/deploy-supabase-functions.yml',
        workflowContent,
        'Add K1W1 EAS build workflow'
      );

      console.log('‚Üí Trigger Workflow...');
// CREATE BUILD JOB FIRST
const buildJobResponse = await fetch(`${process.env.EXPO_PUBLIC_SUPABASE_URL}/rest/v1/build_jobs`, {
  method: 'POST',
  headers: {
    'apikey': process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!,
    'Authorization': `Bearer ${process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    project_name: project.name,
    repository: `${owner}/${finalRepoName}`,
    status: 'queued'
  })
});

const buildJobData = await buildJobResponse.json();
const jobId = buildJobData.id;

console.log(`üìù Build Job erstellt: ${jobId}`);
// CREATE BUILD JOB FIRST
const buildJobResponse = await fetch(`${process.env.EXPO_PUBLIC_SUPABASE_URL}/rest/v1/build_jobs`, {
  method: 'POST',
  headers: {
    'apikey': process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!,
    'Authorization': `Bearer ${process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    project_name: project.name,
    repository: `${owner}/${finalRepoName}`,
    status: 'queued'
  })
});

const buildJobData = await buildJobResponse.json();
const jobId = buildJobData.id;

console.log(`üìù Build Job erstellt: ${jobId}`);
      await triggerWorkflow(owner, finalRepoName, 'deploy-supabase-functions.yml', { job_id: jobId });
      console.log('‚úì GitHub Actions Workflow gestartet');

      Alert.alert(
        '‚úÖ Export erfolgreich!',
        `Repository: ${owner}/${finalRepoName}\n\nüì¶ ${finalFiles.length} Dateien exportiert\nüîÑ GitHub Actions l√§uft...\nüì± APK wird erstellt...`,
        [
          { text: 'OK' }
        ]
      );

      return { owner, repo: finalRepoName };
    } catch (error: any) {
      console.error('‚ùå Fehler in exportAndBuild:', error);
      Alert.alert('Export fehlgeschlagen', error.message || 'Ein unbekannter Fehler ist aufgetreten.');
      return null;
    }
  }, []);

  const createFile = useCallback(async (path: string, content: string) => {
    if (!projectData) return;
    const files = projectData.files || [];
    const existingIndex = files.findIndex(f => f.path === path);
    let newFiles: ProjectFile[];

    if (existingIndex >= 0) {
      newFiles = [...files];
      newFiles[existingIndex] = { path, content };
    } else {
      newFiles = [...files, { path, content }];
    }

    await updateProjectFiles(newFiles);
  }, [projectData, updateProjectFiles]);

  const deleteFile = useCallback(async (path: string) => {
    if (!projectData) return;
    const files = projectData.files || [];
    const newFiles = files.filter(f => f.path !== path);
    await updateProjectFiles(newFiles);
  }, [projectData, updateProjectFiles]);

  const renameFile = useCallback(async (oldPath: string, newPath: string) => {
    if (!projectData) return;
    const files = projectData.files || [];
    const newFiles = files.map(f => 
      f.path === oldPath ? { ...f, path: newPath } : f
    );
    await updateProjectFiles(newFiles);
  }, [projectData, updateProjectFiles]);

  useEffect(() => {
    const initializeProject = async () => {
      try {
        console.log('=== APP START - REPARIERT & UMSTRUKTURIERT ===');
        const savedProject = await loadProjectFromStorage();
        if (savedProject) {
          console.log(`‚úì Projekt geladen: ${savedProject.name}`);
          
          // ‚úÖ SICHERSTELLEN DASS FILES ARRAY EXISTIERT
          if (!savedProject.files) {
            savedProject.files = [];
            console.warn('‚ö†Ô∏è Projekt hatte keine files - Array erstellt');
          }
          
          setProjectData(savedProject);
        }
      } catch (error) {
        console.error('Fehler beim Laden:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initializeProject();
  }, []);

  const value: ProjectContextProps = {
    projectData,
    isLoading,
    updateProjectFiles,
    addChatMessage,
    exportAndBuild,
    getGitHubToken,
    getWorkflowRuns,
    createFile,
    deleteFile,
    renameFile,
    setPackageName,
    exportProjectAsZip,
    importProjectFromZip,
  };

  return (
    <ProjectContext.Provider value={value}>
      {children}
    </ProjectContext.Provider>
  );
};

export const useProject = (): ProjectContextProps => {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within a ProjectProvider');
  }
  return context;
};
